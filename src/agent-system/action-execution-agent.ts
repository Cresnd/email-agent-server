/**
 * Action Execution Agent - Agent 3 of 3-Agent Pipeline
 * Responsible for tool execution, email composition, and infrastructure operations
 */

import { ParsingAgentOutput } from './parsing-agent.ts';
import { BusinessLogicAgentOutput } from './business-logic-agent.ts';
import { DatabaseQueries } from '../database/queries.ts';
import { ToolLoader, DatabaseTool, ToolExecutionResult } from '../database/tool-loader.ts';

export interface EmailProcessingContext {
  subject: string;
  message: string;
  message_for_ai: string;
  customer_email: string;
  first_name: string | null;
  last_name: string | null;
  attachments?: string;
  received_at: string;
  conversation_id: string;
}

export interface VenueSettings {
  venue_id: string;
  venue_name: string;
  venue_address: string;
  venue_description: string;
  venue_timezone: string;
  organization_id: string;
  organization_name: string;
  finance_email: string | null;
}

export interface EmailInfrastructure {
  email_account: string;
  smtp_settings: {
    host: string;
    port: number;
    username: string;
    password: string;
    secure: boolean;
  };
  imap_settings: {
    host: string;
    port: number;
    username: string;
    password: string;
    secure: boolean;
  };
  folders: {
    inbox: string;
    sent: string;
    drafts: string;
    processed: string;
    archive: string;
  };
}

export interface ActionExecutionAgentInput {
  // From Business Logic Agent
  business_logic_output: BusinessLogicAgentOutput;
  
  // Original context (needed for response)
  original_email: EmailProcessingContext;
  customer_data: ParsingAgentOutput['customer'];
  
  // Workflow execution tracking
  workflowExecutionId?: string;
  
  // Venue configuration
  venue_settings: VenueSettings;
  venue_prompts: {
    execution_prompt?: {
      prompt: string;
      checksum: string;
    };
  };
  
  guardrails: {
    final_check_guardrails?: Array<{
      name: string;
      prompt: string;
      threshold: number;
      folder_path?: string;
      mark_as_seen?: boolean;
    }>;
  };
  
  // Email infrastructure
  email_infrastructure: EmailInfrastructure;
}

export interface ActionExecutionAgentOutput {
  // AI execution result (email response generated by execution prompt)
  ai_response: {
    subject: string;
    body_html: string;
    body_text: string;
    from_name: string;
    reply_to?: string;
  };
  
  // Tool execution results
  tool_executions: Array<{
    tool_name: string;
    success: boolean;
    result: any;
    error_message?: string;
    execution_time_ms: number;
  }>;
  
  // Guardrail validation results
  guardrail_status: 'passed' | 'blocked' | 'flagged';
  guardrail_violations?: Array<{
    guardrail_name: string;
    violation_type: 'blocked' | 'flagged';
    confidence: number;
    reasoning: string;
  }>;
  
  // Email operations
  email_operations: {
    send_response: boolean;
    move_to_folder?: string;
    mark_as_seen?: boolean;
    create_draft?: boolean;
  };
  
  // Processing metadata
  executed_at: string;
  final_status: 'success' | 'partial_success' | 'failure';
  processing_notes: string[];
  total_execution_time_ms: number;
}

export class ActionExecutionAgent {
  private db: DatabaseQueries;
  private toolLoader: ToolLoader;
  private currentWorkflowExecutionId?: string;
  private maxRetryAttempts = 3;
  private retryDelayMs = 1000; // Base delay for exponential backoff

  constructor() {
    this.db = new DatabaseQueries();
    this.toolLoader = new ToolLoader();
  }

  /**
   * Main processing method for Action Execution Agent
   * Uses AI with venue-specific execution prompt to generate email responses and execute actions
   */
  async process(input: ActionExecutionAgentInput): Promise<ActionExecutionAgentOutput> {
    const startTime = Date.now();
    const processingNotes: string[] = [];
    
    // Store workflowExecutionId for tool logging
    this.currentWorkflowExecutionId = input.workflowExecutionId;

    try {
      // 1. Validate that we have the execution prompt
      if (!input.venue_prompts.execution_prompt?.prompt) {
        throw new Error('Missing execution prompt for venue');
      }
      
      processingNotes.push(`Using execution prompt (checksum: ${input.venue_prompts.execution_prompt.checksum})`);

      // 2. Prepare AI input with all context from previous agents
      const aiInput = this.prepareExecutionInput(input);
      processingNotes.push(`Prepared execution input for action: ${input.business_logic_output.decision.action_type}`);

      // 3. Call AI with execution prompt to generate email response and execute any tools
      const executionResult = await this.callExecutionAI(
        input.venue_prompts.execution_prompt.prompt,
        aiInput
      );
      processingNotes.push(`Execution AI completed - generated email response`);

      // 4. Execute any required tools based on the action type
      const toolExecutions = await this.executeRequiredTools(
        input.business_logic_output.decision.action_type,
        input.business_logic_output.refined_extraction,
        input.venue_settings
      );
      processingNotes.push(`Tool executions completed: ${toolExecutions.length} tools called`);

      // 5. Apply final check guardrails to the generated response
      const guardrailResults = await this.applyFinalCheckGuardrails(
        executionResult,
        input.guardrails.final_check_guardrails || []
      );
      processingNotes.push(`Final check guardrails applied - status: ${guardrailResults.status}`);

      // 6. Determine email operations based on guardrail results
      const emailOperations = this.determineEmailOperations(
        input.business_logic_output.decision,
        guardrailResults
      );

      // 7. Determine final status
      const finalStatus = this.determineFinalStatus(toolExecutions, guardrailResults);
      
      const totalExecutionTime = Date.now() - startTime;

      return {
        ai_response: executionResult.email_response,
        tool_executions: toolExecutions,
        guardrail_status: guardrailResults.status,
        guardrail_violations: guardrailResults.violations,
        email_operations: emailOperations,
        executed_at: new Date().toISOString(),
        final_status: finalStatus,
        processing_notes: processingNotes,
        total_execution_time_ms: totalExecutionTime
      };

    } catch (error) {
      const totalExecutionTime = Date.now() - startTime;
      
      // Create fallback response for critical failures
      const fallbackResponse = this.createFallbackEmailResponse(
        input.original_email,
        input.customer_data,
        input.venue_settings,
        error as Error
      );

      return {
        ai_response: fallbackResponse,
        tool_executions: [],
        guardrail_status: 'flagged',
        guardrail_violations: [{
          guardrail_name: 'execution_error',
          violation_type: 'flagged',
          confidence: 1.0,
          reasoning: (error as Error).message
        }],
        email_operations: {
          send_response: false,
          create_draft: true,
          move_to_folder: 'drafts'
        },
        executed_at: new Date().toISOString(),
        final_status: 'failure',
        processing_notes: [...processingNotes, `Critical failure: ${(error as Error).message}`],
        total_execution_time_ms: totalExecutionTime
      };
    }
  }

  /**
   * Prepare input for execution AI with all context from previous agents
   */
  private prepareExecutionInput(input: ActionExecutionAgentInput): string {
    const businessLogic = input.business_logic_output;
    const originalEmail = input.original_email;
    const venueInfo = input.venue_settings;
    
    return `
VENUE CONTEXT:
- Venue: ${venueInfo.venue_name}
- Address: ${venueInfo.venue_address}
- Organization: ${venueInfo.organization_name}

ORIGINAL EMAIL:
Subject: ${originalEmail.subject}
From: ${originalEmail.customer_email}
Message: ${originalEmail.message_for_ai}

BUSINESS DECISION:
- Action: ${businessLogic.decision.action_type}
- Reasoning: ${businessLogic.decision.reasoning}
- Requires Review: ${businessLogic.decision.requires_human_review}

EXTRACTED DATA:
${JSON.stringify(businessLogic.refined_extraction, null, 2)}

CONTEXT: This email requires action type "${businessLogic.decision.action_type}". Generate an appropriate email response in JSON format.
    `.trim();
  }

  /**
   * Call execution AI to generate email response
   */
  private async callExecutionAI(
    executionPrompt: string,
    executionInput: string
  ): Promise<{
    email_response: ActionExecutionAgentOutput['ai_response'];
  }> {
    
    try {
      const apiKey = Deno.env.get('OPENAI_API_KEY');
      if (!apiKey) {
        throw new Error('OpenAI API key not found in environment variables');
      }

      // Ensure the prompt contains "json" for OpenAI's json_object format requirement
      const systemPrompt = executionPrompt.toLowerCase().includes('json') 
        ? executionPrompt 
        : executionPrompt + '\n\nYou must respond with valid JSON format.';

      // Make OpenAI API call
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: systemPrompt
            },
            {
              role: 'user',
              content: executionInput
            }
          ],
          temperature: 0.3,
          max_tokens: 2000,
          response_format: { type: "json_object" }
        })
      });

      if (!response.ok) {
        const errorBody = await response.text();
        console.error('OpenAI API Error Details:', {
          status: response.status,
          statusText: response.statusText,
          body: errorBody
        });
        throw new Error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      const data = await response.json();
      const aiResponse = data.choices?.[0]?.message?.content;

      if (!aiResponse) {
        throw new Error('No response from OpenAI API');
      }

      // Parse the JSON response
      let executionResult;
      try {
        executionResult = JSON.parse(aiResponse);
      } catch (parseError) {
        throw new Error(`Failed to parse AI response as JSON: ${parseError}`);
      }

      // Validate the response structure and provide defaults
      const emailResponse = {
        subject: executionResult.email_response?.subject || 'Re: Your inquiry',
        body_html: executionResult.email_response?.body_html || executionResult.email_response?.body_text || 'Thank you for your message.',
        body_text: executionResult.email_response?.body_text || executionResult.email_response?.body_html || 'Thank you for your message.',
        from_name: executionResult.email_response?.from_name || 'Restaurant Team',
        reply_to: executionResult.email_response?.reply_to
      };

      return {
        email_response: emailResponse
      };

    } catch (error) {
      console.error('Execution AI call failed:', error);
      
      // Fallback to rule-based email generation when AI fails
      const inputLines = executionInput.split('\n');
      const actionLine = inputLines.find(line => line.includes('Action:'));
      
      let subject = 'Re: Your inquiry';
      let body = `Thank you for your message. We will get back to you shortly. (AI processing temporarily unavailable: ${error instanceof Error ? error.message : String(error)})`;
      
      if (actionLine?.includes('make_booking')) {
        subject = 'Booking Confirmation';
        body = 'Thank you for your booking request. Your reservation has been confirmed.';
      } else if (actionLine?.includes('edit_booking')) {
        subject = 'Booking Updated';
        body = 'Your booking has been successfully updated.';
      } else if (actionLine?.includes('cancel_booking')) {
        subject = 'Booking Cancelled';
        body = 'Your booking has been cancelled as requested.';
      }
      
      return {
        email_response: {
          subject,
          body_html: body,
          body_text: body,
          from_name: 'Restaurant Team'
        }
      };
    }
  }

  /**
   * Execute required tools based on action type - Now database-driven!
   */
  private async executeRequiredTools(
    actionType: string,
    extractionData: any,
    venueSettings: VenueSettings
  ): Promise<ActionExecutionAgentOutput['tool_executions']> {
    
    const toolExecutions: ActionExecutionAgentOutput['tool_executions'] = [];
    
    try {
      // Load available tools from database
      const availableTools = await this.toolLoader.loadAvailableTools();
      
      // Determine which tools to execute based on action type
      const toolsToExecute = this.determineToolsForAction(actionType, availableTools);
      
      // Execute each tool
      for (const tool of toolsToExecute) {
        const toolResult = await this.executeTool(tool, extractionData, venueSettings, this.currentWorkflowExecutionId);
        
        toolExecutions.push({
          tool_name: toolResult.tool_name,
          success: toolResult.success,
          result: toolResult.result,
          error_message: toolResult.error,
          execution_time_ms: toolResult.execution_time_ms
        });
      }
      
    } catch (error) {
      // Fallback to mock execution if database tools fail
      console.warn('Database tool execution failed, using fallback:', error);
      return this.getFallbackToolExecutions(actionType, extractionData);
    }
    
    return toolExecutions;
  }

  /**
   * Determine which tools to execute for a given action type
   */
  private determineToolsForAction(actionType: string, availableTools: DatabaseTool[]): DatabaseTool[] {
    const toolsToExecute: DatabaseTool[] = [];
    
    switch (actionType) {
      case 'make_booking':
        // For booking: check availability, then make booking
        toolsToExecute.push(
          ...availableTools.filter(t => ['get_availability', 'make_booking'].includes(t.tool_name))
        );
        break;
        
      case 'edit_booking':
        // For editing: get existing booking, then edit
        toolsToExecute.push(
          ...availableTools.filter(t => ['get_bookings', 'edit_booking'].includes(t.tool_name))
        );
        break;
        
      case 'cancel_booking':
        // For cancellation: get booking, then cancel
        toolsToExecute.push(
          ...availableTools.filter(t => ['get_bookings', 'make_cancellation'].includes(t.tool_name))
        );
        break;
        
      case 'answer_question':
        // For questions: check FAQ/menu
        toolsToExecute.push(
          ...availableTools.filter(t => ['get_FAQ', 'get_menu'].includes(t.tool_name))
        );
        break;
        
      default:
        // Always include send_email for responses
        toolsToExecute.push(
          ...availableTools.filter(t => t.tool_name === 'send_email')
        );
    }
    
    return toolsToExecute;
  }

  /**
   * Execute a single tool with proper context
   */
  private async executeTool(
    tool: DatabaseTool, 
    extractionData: any, 
    venueSettings: VenueSettings,
    workflowExecutionId?: string
  ): Promise<ToolExecutionResult> {
    
    // Prepare context for tool execution
    const context = {
      venue_id: venueSettings.venue_id,
      database_project_ref: 'qaymciaujneyqhsbycmp', // From your Supabase project
      ...extractionData
    };
    
    return await this.toolLoader.executeTool(tool, extractionData, context, workflowExecutionId);
  }

  /**
   * Fallback tool executions if database loading fails
   */
  private getFallbackToolExecutions(actionType: string, extractionData: any) {
    const toolExecutions: ActionExecutionAgentOutput['tool_executions'] = [];
    
    if (actionType === 'make_booking') {
      toolExecutions.push({
        tool_name: 'make_booking_fallback',
        success: true,
        result: { booking_id: 'booking_' + Date.now(), status: 'confirmed' },
        execution_time_ms: 150
      });
    } else if (actionType === 'edit_booking') {
      toolExecutions.push({
        tool_name: 'edit_booking_fallback',
        success: true,
        result: { booking_id: extractionData.bookingref, status: 'updated' },
        execution_time_ms: 120
      });
    } else if (actionType === 'cancel_booking') {
      toolExecutions.push({
        tool_name: 'cancel_booking_fallback',
        success: true,
        result: { booking_id: extractionData.bookingref, status: 'cancelled' },
        execution_time_ms: 100
      });
    }
    
    return toolExecutions;
  }

  /**
   * Apply final check guardrails to the generated email response
   */
  private async applyFinalCheckGuardrails(
    executionResult: any,
    guardrails: Array<{
      name: string;
      prompt: string;
      threshold: number;
      folder_path?: string;
      mark_as_seen?: boolean;
    }>
  ): Promise<{
    status: 'passed' | 'blocked' | 'flagged';
    violations: Array<{
      guardrail_name: string;
      violation_type: 'blocked' | 'flagged';
      confidence: number;
      reasoning: string;
    }>;
  }> {
    
    const violations: Array<{
      guardrail_name: string;
      violation_type: 'blocked' | 'flagged';
      confidence: number;
      reasoning: string;
    }> = [];
    
    // TODO: Implement actual guardrail evaluation using AI
    // For now, returning a mock that passes all guardrails
    
    return {
      status: 'passed',
      violations: violations
    };
  }

  /**
   * Determine email operations based on decision and guardrail results
   */
  private determineEmailOperations(
    decision: any,
    guardrailResults: any
  ): ActionExecutionAgentOutput['email_operations'] {
    
    // Don't send if blocked by guardrails or requires human review
    const shouldSend = guardrailResults.status !== 'blocked' && !decision.requires_human_review;
    
    return {
      send_response: shouldSend,
      move_to_folder: shouldSend ? 'processed' : 'inbox',
      mark_as_seen: shouldSend,
      create_draft: !shouldSend
    };
  }

  /**
   * Determine final status based on tool executions and guardrails
   */
  private determineFinalStatus(
    toolExecutions: ActionExecutionAgentOutput['tool_executions'],
    guardrailResults: any
  ): 'success' | 'partial_success' | 'failure' {
    
    if (guardrailResults.status === 'blocked') {
      return 'failure';
    }
    
    const allToolsSucceeded = toolExecutions.every(tool => tool.success);
    
    if (allToolsSucceeded && guardrailResults.status === 'passed') {
      return 'success';
    } else if (allToolsSucceeded && guardrailResults.status === 'flagged') {
      return 'partial_success';
    } else {
      return 'failure';
    }
  }

  /**
   * Create fallback email response for critical failures
   */
  private createFallbackEmailResponse(
    originalEmail: EmailProcessingContext,
    customerData: ParsingAgentOutput['customer'],
    venueSettings: VenueSettings,
    error: Error
  ): ActionExecutionAgentOutput['ai_response'] {
    const customerName = customerData?.first_name || 'Valued Customer';
    
    const body = `Dear ${customerName},\n\nThank you for contacting ${venueSettings.venue_name}. We've received your message and will respond as soon as possible.\n\nBest regards,\n${venueSettings.venue_name} Team`;
    
    return {
      subject: `Re: ${originalEmail.subject} - We'll get back to you soon`,
      body_html: body,
      body_text: body,
      from_name: venueSettings.venue_name
    };
  }
}